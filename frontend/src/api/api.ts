/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * freeheat_test API
 * Documentation of API endpoints of freeheat_test
 * OpenAPI spec version: 1.0.0
 */
import {
  useQuery,
  useInfiniteQuery,
  useMutation
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseInfiniteQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  UseInfiniteQueryResult,
  QueryKey
} from '@tanstack/react-query'
import type {
  Token,
  Login,
  RestAuthDetail,
  PasswordChange,
  PasswordReset,
  PasswordResetConfirm,
  Registration,
  UserDetails,
  PatchedUserDetails,
  ApiSchemaRetrieve200One,
  ApiSchemaRetrieve200Two,
  ApiSchemaRetrieve200Three,
  ApiSchemaRetrieve200Four,
  ApiSchemaRetrieveParams,
  User,
  PatchedUser
} from '.././model'
import { axiosInstance } from '.././api/custom-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



// eslint-disable-next-line
  type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

/**
 * Check the credentials and return the REST Token
if the credentials are valid and authenticated.
Calls Django Auth login method to register User ID
in Django session framework

Accept the following POST parameters: username, password
Return the REST Framework Token Object's key.
 */
export const apiDjRestAuthLoginCreate = (
    login: Login,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<Token>(
      {url: `/api/dj-rest-auth/login/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: login
    },
      options);
    }
  


export const getApiDjRestAuthLoginCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>, TError,{data: Login}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>, TError,{data: Login}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>, {data: Login}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthLoginCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthLoginCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>>
    export type ApiDjRestAuthLoginCreateMutationBody = Login
    export type ApiDjRestAuthLoginCreateMutationError = unknown

    export const useApiDjRestAuthLoginCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>, TError,{data: Login}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthLoginCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Calls Django logout method and delete the Token object
assigned to the current User object.

Accepts/Returns nothing.
 */
export const apiDjRestAuthLogoutCreate = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<RestAuthDetail>(
      {url: `/api/dj-rest-auth/logout/`, method: 'post'
    },
      options);
    }
  


export const getApiDjRestAuthLogoutCreateMutationOptions = <TError = unknown,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>, TError,TVariables, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>, TError,TVariables, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>, TVariables> = () => {
          

          return  apiDjRestAuthLogoutCreate(requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthLogoutCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>>
    
    export type ApiDjRestAuthLogoutCreateMutationError = unknown

    export const useApiDjRestAuthLogoutCreate = <TError = unknown,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>, TError,TVariables, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthLogoutCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Calls Django Auth SetPasswordForm save method.

Accepts the following POST parameters: new_password1, new_password2
Returns the success/fail message.
 */
export const apiDjRestAuthPasswordChangeCreate = (
    passwordChange: PasswordChange,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<RestAuthDetail>(
      {url: `/api/dj-rest-auth/password/change/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: passwordChange
    },
      options);
    }
  


export const getApiDjRestAuthPasswordChangeCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>, TError,{data: PasswordChange}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>, TError,{data: PasswordChange}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>, {data: PasswordChange}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthPasswordChangeCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthPasswordChangeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>>
    export type ApiDjRestAuthPasswordChangeCreateMutationBody = PasswordChange
    export type ApiDjRestAuthPasswordChangeCreateMutationError = unknown

    export const useApiDjRestAuthPasswordChangeCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>, TError,{data: PasswordChange}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthPasswordChangeCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Calls Django Auth PasswordResetForm save method.

Accepts the following POST parameters: email
Returns the success/fail message.
 */
export const apiDjRestAuthPasswordResetCreate = (
    passwordReset: PasswordReset,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<RestAuthDetail>(
      {url: `/api/dj-rest-auth/password/reset/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: passwordReset
    },
      options);
    }
  


export const getApiDjRestAuthPasswordResetCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>, TError,{data: PasswordReset}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>, TError,{data: PasswordReset}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>, {data: PasswordReset}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthPasswordResetCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthPasswordResetCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>>
    export type ApiDjRestAuthPasswordResetCreateMutationBody = PasswordReset
    export type ApiDjRestAuthPasswordResetCreateMutationError = unknown

    export const useApiDjRestAuthPasswordResetCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>, TError,{data: PasswordReset}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthPasswordResetCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Password reset e-mail link is confirmed, therefore
this resets the user's password.

Accepts the following POST parameters: token, uid,
    new_password1, new_password2
Returns the success/fail message.
 */
export const apiDjRestAuthPasswordResetConfirmCreate = (
    passwordResetConfirm: PasswordResetConfirm,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<RestAuthDetail>(
      {url: `/api/dj-rest-auth/password/reset/confirm/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: passwordResetConfirm
    },
      options);
    }
  


export const getApiDjRestAuthPasswordResetConfirmCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>, TError,{data: PasswordResetConfirm}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>, TError,{data: PasswordResetConfirm}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>, {data: PasswordResetConfirm}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthPasswordResetConfirmCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthPasswordResetConfirmCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>>
    export type ApiDjRestAuthPasswordResetConfirmCreateMutationBody = PasswordResetConfirm
    export type ApiDjRestAuthPasswordResetConfirmCreateMutationError = unknown

    export const useApiDjRestAuthPasswordResetConfirmCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>, TError,{data: PasswordResetConfirm}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthPasswordResetConfirmCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiDjRestAuthRegisterCreate = (
    registration: Registration,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<Registration>(
      {url: `/api/dj-rest-auth/register/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: registration
    },
      options);
    }
  


export const getApiDjRestAuthRegisterCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>, TError,{data: Registration}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>, TError,{data: Registration}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>, {data: Registration}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthRegisterCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthRegisterCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>>
    export type ApiDjRestAuthRegisterCreateMutationBody = Registration
    export type ApiDjRestAuthRegisterCreateMutationError = unknown

    export const useApiDjRestAuthRegisterCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>, TError,{data: Registration}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthRegisterCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Reads and updates UserModel fields
Accepts GET, PUT, PATCH methods.

Default accepted fields: username, first_name, last_name
Default display fields: pk, username, email, first_name, last_name
Read-only fields: pk, email

Returns UserModel fields.
 */
export const apiDjRestAuthUserRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<UserDetails>(
      {url: `/api/dj-rest-auth/user/`, method: 'get', signal
    },
      options);
    }
  

export const getApiDjRestAuthUserRetrieveQueryKey = () => [`/api/dj-rest-auth/user/`] as const;
  

    
export const getApiDjRestAuthUserRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError = unknown>( options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiDjRestAuthUserRetrieveQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>> = ({ signal }) => apiDjRestAuthUserRetrieve(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiDjRestAuthUserRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>>
export type ApiDjRestAuthUserRetrieveInfiniteQueryError = unknown

export const useApiDjRestAuthUserRetrieveInfinite = <TData = Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError = unknown>(
  options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiDjRestAuthUserRetrieveInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiDjRestAuthUserRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiDjRestAuthUserRetrieveQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>> = ({ signal }) => apiDjRestAuthUserRetrieve(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiDjRestAuthUserRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>>
export type ApiDjRestAuthUserRetrieveQueryError = unknown

export const useApiDjRestAuthUserRetrieve = <TData = Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiDjRestAuthUserRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

/**
 * Reads and updates UserModel fields
Accepts GET, PUT, PATCH methods.

Default accepted fields: username, first_name, last_name
Default display fields: pk, username, email, first_name, last_name
Read-only fields: pk, email

Returns UserModel fields.
 */
export const apiDjRestAuthUserUpdate = (
    userDetails: NonReadonly<UserDetails>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<UserDetails>(
      {url: `/api/dj-rest-auth/user/`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: userDetails
    },
      options);
    }
  


export const getApiDjRestAuthUserUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>, TError,{data: NonReadonly<UserDetails>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>, TError,{data: NonReadonly<UserDetails>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>, {data: NonReadonly<UserDetails>}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthUserUpdate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthUserUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>>
    export type ApiDjRestAuthUserUpdateMutationBody = NonReadonly<UserDetails>
    export type ApiDjRestAuthUserUpdateMutationError = unknown

    export const useApiDjRestAuthUserUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>, TError,{data: NonReadonly<UserDetails>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthUserUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Reads and updates UserModel fields
Accepts GET, PUT, PATCH methods.

Default accepted fields: username, first_name, last_name
Default display fields: pk, username, email, first_name, last_name
Read-only fields: pk, email

Returns UserModel fields.
 */
export const apiDjRestAuthUserPartialUpdate = (
    patchedUserDetails: NonReadonly<PatchedUserDetails>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<UserDetails>(
      {url: `/api/dj-rest-auth/user/`, method: 'patch',
      headers: {'Content-Type': 'application/json', },
      data: patchedUserDetails
    },
      options);
    }
  


export const getApiDjRestAuthUserPartialUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>, TError,{data: NonReadonly<PatchedUserDetails>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>, TError,{data: NonReadonly<PatchedUserDetails>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>, {data: NonReadonly<PatchedUserDetails>}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthUserPartialUpdate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthUserPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>>
    export type ApiDjRestAuthUserPartialUpdateMutationBody = NonReadonly<PatchedUserDetails>
    export type ApiDjRestAuthUserPartialUpdateMutationError = unknown

    export const useApiDjRestAuthUserPartialUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>, TError,{data: NonReadonly<PatchedUserDetails>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthUserPartialUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * OpenApi3 schema for this API. Format can be selected via content negotiation.

- YAML: application/vnd.oai.openapi
- JSON: application/vnd.oai.openapi+json
 */
export const apiSchemaRetrieve = (
    params?: ApiSchemaRetrieveParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<ApiSchemaRetrieve200One | ApiSchemaRetrieve200Two | ApiSchemaRetrieve200Three | ApiSchemaRetrieve200Four>(
      {url: `/api/schema/`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getApiSchemaRetrieveQueryKey = (params?: ApiSchemaRetrieveParams,) => [`/api/schema/`, ...(params ? [params]: [])] as const;
  

    
export const getApiSchemaRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = unknown>(params?: ApiSchemaRetrieveParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiSchemaRetrieveQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiSchemaRetrieve>>> = ({ signal }) => apiSchemaRetrieve(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiSchemaRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiSchemaRetrieve>>>
export type ApiSchemaRetrieveInfiniteQueryError = unknown

export const useApiSchemaRetrieveInfinite = <TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = unknown>(
 params?: ApiSchemaRetrieveParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiSchemaRetrieveInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiSchemaRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = unknown>(params?: ApiSchemaRetrieveParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiSchemaRetrieveQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiSchemaRetrieve>>> = ({ signal }) => apiSchemaRetrieve(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiSchemaRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiSchemaRetrieve>>>
export type ApiSchemaRetrieveQueryError = unknown

export const useApiSchemaRetrieve = <TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = unknown>(
 params?: ApiSchemaRetrieveParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiSchemaRetrieveQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const apiUsersList = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<User[]>(
      {url: `/api/users/`, method: 'get', signal
    },
      options);
    }
  

export const getApiUsersListQueryKey = () => [`/api/users/`] as const;
  

    
export const getApiUsersListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersList>>, TError = unknown>( options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersListQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersList>>> = ({ signal }) => apiUsersList(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersList>>>
export type ApiUsersListInfiniteQueryError = unknown

export const useApiUsersListInfinite = <TData = Awaited<ReturnType<typeof apiUsersList>>, TError = unknown>(
  options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersListInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiUsersListQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersList>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersListQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersList>>> = ({ signal }) => apiUsersList(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersListQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersList>>>
export type ApiUsersListQueryError = unknown

export const useApiUsersList = <TData = Awaited<ReturnType<typeof apiUsersList>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const apiUsersRetrieve = (
    username: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<User>(
      {url: `/api/users/${username}/`, method: 'get', signal
    },
      options);
    }
  

export const getApiUsersRetrieveQueryKey = (username: string,) => [`/api/users/${username}/`] as const;
  

    
export const getApiUsersRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersRetrieve>>, TError = unknown>(username: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersRetrieveQueryKey(username);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersRetrieve>>> = ({ signal }) => apiUsersRetrieve(username, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(username),  staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersRetrieve>>>
export type ApiUsersRetrieveInfiniteQueryError = unknown

export const useApiUsersRetrieveInfinite = <TData = Awaited<ReturnType<typeof apiUsersRetrieve>>, TError = unknown>(
 username: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersRetrieveInfiniteQueryOptions(username,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiUsersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersRetrieve>>, TError = unknown>(username: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersRetrieveQueryKey(username);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersRetrieve>>> = ({ signal }) => apiUsersRetrieve(username, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(username),  staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersRetrieve>>>
export type ApiUsersRetrieveQueryError = unknown

export const useApiUsersRetrieve = <TData = Awaited<ReturnType<typeof apiUsersRetrieve>>, TError = unknown>(
 username: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersRetrieveQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const apiUsersUpdate = (
    username: string,
    user: NonReadonly<User>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<User>(
      {url: `/api/users/${username}/`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: user
    },
      options);
    }
  


export const getApiUsersUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersUpdate>>, TError,{username: string;data: NonReadonly<User>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersUpdate>>, TError,{username: string;data: NonReadonly<User>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersUpdate>>, {username: string;data: NonReadonly<User>}> = (props) => {
          const {username,data} = props ?? {};

          return  apiUsersUpdate(username,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiUsersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersUpdate>>>
    export type ApiUsersUpdateMutationBody = NonReadonly<User>
    export type ApiUsersUpdateMutationError = unknown

    export const useApiUsersUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersUpdate>>, TError,{username: string;data: NonReadonly<User>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiUsersUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiUsersPartialUpdate = (
    username: string,
    patchedUser: NonReadonly<PatchedUser>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<User>(
      {url: `/api/users/${username}/`, method: 'patch',
      headers: {'Content-Type': 'application/json', },
      data: patchedUser
    },
      options);
    }
  


export const getApiUsersPartialUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersPartialUpdate>>, TError,{username: string;data: NonReadonly<PatchedUser>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersPartialUpdate>>, TError,{username: string;data: NonReadonly<PatchedUser>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersPartialUpdate>>, {username: string;data: NonReadonly<PatchedUser>}> = (props) => {
          const {username,data} = props ?? {};

          return  apiUsersPartialUpdate(username,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiUsersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersPartialUpdate>>>
    export type ApiUsersPartialUpdateMutationBody = NonReadonly<PatchedUser>
    export type ApiUsersPartialUpdateMutationError = unknown

    export const useApiUsersPartialUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersPartialUpdate>>, TError,{username: string;data: NonReadonly<PatchedUser>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiUsersPartialUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiUsersMeRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<User>(
      {url: `/api/users/me/`, method: 'get', signal
    },
      options);
    }
  

export const getApiUsersMeRetrieveQueryKey = () => [`/api/users/me/`] as const;
  

    
export const getApiUsersMeRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError = unknown>( options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersMeRetrieveQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersMeRetrieve>>> = ({ signal }) => apiUsersMeRetrieve(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersMeRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersMeRetrieve>>>
export type ApiUsersMeRetrieveInfiniteQueryError = unknown

export const useApiUsersMeRetrieveInfinite = <TData = Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError = unknown>(
  options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersMeRetrieveInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiUsersMeRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersMeRetrieveQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersMeRetrieve>>> = ({ signal }) => apiUsersMeRetrieve(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersMeRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersMeRetrieve>>>
export type ApiUsersMeRetrieveQueryError = unknown

export const useApiUsersMeRetrieve = <TData = Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersMeRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

