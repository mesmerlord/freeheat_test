/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * freeheat_test API
 * Documentation of API endpoints of freeheat_test
 * OpenAPI spec version: 1.0.0
 */
import {
  useQuery,
  useInfiniteQuery,
  useMutation
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseInfiniteQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  UseInfiniteQueryResult,
  QueryKey
} from '@tanstack/react-query'
import type {
  Token,
  Login,
  RestAuthDetail,
  PasswordChange,
  PasswordReset,
  PasswordResetConfirm,
  Registration,
  UserDetails,
  PatchedUserDetails,
  PaginatedEnergyPriceLogModelList,
  ApiEnergyLogsListParams,
  ApiEnergyLogsUploadCsvCreate201,
  ApiEnergyLogsUploadCsvCreate400,
  ApiEnergyLogsUploadCsvCreateBody,
  ApiSchemaRetrieve200One,
  ApiSchemaRetrieve200Two,
  ApiSchemaRetrieve200Three,
  ApiSchemaRetrieve200Four,
  ApiSchemaRetrieveParams,
  PaginatedUserCarChargeLogModelList,
  ApiUserCarChargeLogsListParams,
  PaginatedUserCarModelList,
  ApiUserCarsListParams,
  UserCarModel,
  UserCarDetailModel,
  PatchedUserCarModel,
  PaginatedUserList,
  ApiUsersListParams,
  User,
  PatchedUser
} from '.././model'
import { axiosInstance } from '.././api/custom-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



// eslint-disable-next-line
  type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

/**
 * Check the credentials and return the REST Token
if the credentials are valid and authenticated.
Calls Django Auth login method to register User ID
in Django session framework

Accept the following POST parameters: username, password
Return the REST Framework Token Object's key.
 */
export const apiDjRestAuthLoginCreate = (
    login: Login,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<Token>(
      {url: `/api/dj-rest-auth/login/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: login
    },
      options);
    }
  


export const getApiDjRestAuthLoginCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>, TError,{data: Login}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>, TError,{data: Login}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>, {data: Login}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthLoginCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthLoginCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>>
    export type ApiDjRestAuthLoginCreateMutationBody = Login
    export type ApiDjRestAuthLoginCreateMutationError = unknown

    export const useApiDjRestAuthLoginCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLoginCreate>>, TError,{data: Login}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthLoginCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Calls Django logout method and delete the Token object
assigned to the current User object.

Accepts/Returns nothing.
 */
export const apiDjRestAuthLogoutCreate = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<RestAuthDetail>(
      {url: `/api/dj-rest-auth/logout/`, method: 'post'
    },
      options);
    }
  


export const getApiDjRestAuthLogoutCreateMutationOptions = <TError = unknown,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>, TError,TVariables, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>, TError,TVariables, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>, TVariables> = () => {
          

          return  apiDjRestAuthLogoutCreate(requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthLogoutCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>>
    
    export type ApiDjRestAuthLogoutCreateMutationError = unknown

    export const useApiDjRestAuthLogoutCreate = <TError = unknown,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthLogoutCreate>>, TError,TVariables, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthLogoutCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Calls Django Auth SetPasswordForm save method.

Accepts the following POST parameters: new_password1, new_password2
Returns the success/fail message.
 */
export const apiDjRestAuthPasswordChangeCreate = (
    passwordChange: PasswordChange,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<RestAuthDetail>(
      {url: `/api/dj-rest-auth/password/change/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: passwordChange
    },
      options);
    }
  


export const getApiDjRestAuthPasswordChangeCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>, TError,{data: PasswordChange}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>, TError,{data: PasswordChange}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>, {data: PasswordChange}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthPasswordChangeCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthPasswordChangeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>>
    export type ApiDjRestAuthPasswordChangeCreateMutationBody = PasswordChange
    export type ApiDjRestAuthPasswordChangeCreateMutationError = unknown

    export const useApiDjRestAuthPasswordChangeCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordChangeCreate>>, TError,{data: PasswordChange}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthPasswordChangeCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Calls Django Auth PasswordResetForm save method.

Accepts the following POST parameters: email
Returns the success/fail message.
 */
export const apiDjRestAuthPasswordResetCreate = (
    passwordReset: PasswordReset,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<RestAuthDetail>(
      {url: `/api/dj-rest-auth/password/reset/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: passwordReset
    },
      options);
    }
  


export const getApiDjRestAuthPasswordResetCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>, TError,{data: PasswordReset}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>, TError,{data: PasswordReset}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>, {data: PasswordReset}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthPasswordResetCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthPasswordResetCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>>
    export type ApiDjRestAuthPasswordResetCreateMutationBody = PasswordReset
    export type ApiDjRestAuthPasswordResetCreateMutationError = unknown

    export const useApiDjRestAuthPasswordResetCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetCreate>>, TError,{data: PasswordReset}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthPasswordResetCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Password reset e-mail link is confirmed, therefore
this resets the user's password.

Accepts the following POST parameters: token, uid,
    new_password1, new_password2
Returns the success/fail message.
 */
export const apiDjRestAuthPasswordResetConfirmCreate = (
    passwordResetConfirm: PasswordResetConfirm,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<RestAuthDetail>(
      {url: `/api/dj-rest-auth/password/reset/confirm/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: passwordResetConfirm
    },
      options);
    }
  


export const getApiDjRestAuthPasswordResetConfirmCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>, TError,{data: PasswordResetConfirm}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>, TError,{data: PasswordResetConfirm}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>, {data: PasswordResetConfirm}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthPasswordResetConfirmCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthPasswordResetConfirmCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>>
    export type ApiDjRestAuthPasswordResetConfirmCreateMutationBody = PasswordResetConfirm
    export type ApiDjRestAuthPasswordResetConfirmCreateMutationError = unknown

    export const useApiDjRestAuthPasswordResetConfirmCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthPasswordResetConfirmCreate>>, TError,{data: PasswordResetConfirm}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthPasswordResetConfirmCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiDjRestAuthRegisterCreate = (
    registration: Registration,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<Registration>(
      {url: `/api/dj-rest-auth/register/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: registration
    },
      options);
    }
  


export const getApiDjRestAuthRegisterCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>, TError,{data: Registration}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>, TError,{data: Registration}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>, {data: Registration}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthRegisterCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthRegisterCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>>
    export type ApiDjRestAuthRegisterCreateMutationBody = Registration
    export type ApiDjRestAuthRegisterCreateMutationError = unknown

    export const useApiDjRestAuthRegisterCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthRegisterCreate>>, TError,{data: Registration}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthRegisterCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Reads and updates UserModel fields
Accepts GET, PUT, PATCH methods.

Default accepted fields: username, first_name, last_name
Default display fields: pk, username, email, first_name, last_name
Read-only fields: pk, email

Returns UserModel fields.
 */
export const apiDjRestAuthUserRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<UserDetails>(
      {url: `/api/dj-rest-auth/user/`, method: 'get', signal
    },
      options);
    }
  

export const getApiDjRestAuthUserRetrieveQueryKey = () => [`/api/dj-rest-auth/user/`] as const;
  

    
export const getApiDjRestAuthUserRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError = unknown>( options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiDjRestAuthUserRetrieveQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>> = ({ signal }) => apiDjRestAuthUserRetrieve(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiDjRestAuthUserRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>>
export type ApiDjRestAuthUserRetrieveInfiniteQueryError = unknown

export const useApiDjRestAuthUserRetrieveInfinite = <TData = Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError = unknown>(
  options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiDjRestAuthUserRetrieveInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiDjRestAuthUserRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiDjRestAuthUserRetrieveQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>> = ({ signal }) => apiDjRestAuthUserRetrieve(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiDjRestAuthUserRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>>
export type ApiDjRestAuthUserRetrieveQueryError = unknown

export const useApiDjRestAuthUserRetrieve = <TData = Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiDjRestAuthUserRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiDjRestAuthUserRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

/**
 * Reads and updates UserModel fields
Accepts GET, PUT, PATCH methods.

Default accepted fields: username, first_name, last_name
Default display fields: pk, username, email, first_name, last_name
Read-only fields: pk, email

Returns UserModel fields.
 */
export const apiDjRestAuthUserUpdate = (
    userDetails: NonReadonly<UserDetails>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<UserDetails>(
      {url: `/api/dj-rest-auth/user/`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: userDetails
    },
      options);
    }
  


export const getApiDjRestAuthUserUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>, TError,{data: NonReadonly<UserDetails>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>, TError,{data: NonReadonly<UserDetails>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>, {data: NonReadonly<UserDetails>}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthUserUpdate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthUserUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>>
    export type ApiDjRestAuthUserUpdateMutationBody = NonReadonly<UserDetails>
    export type ApiDjRestAuthUserUpdateMutationError = unknown

    export const useApiDjRestAuthUserUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserUpdate>>, TError,{data: NonReadonly<UserDetails>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthUserUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * Reads and updates UserModel fields
Accepts GET, PUT, PATCH methods.

Default accepted fields: username, first_name, last_name
Default display fields: pk, username, email, first_name, last_name
Read-only fields: pk, email

Returns UserModel fields.
 */
export const apiDjRestAuthUserPartialUpdate = (
    patchedUserDetails: NonReadonly<PatchedUserDetails>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<UserDetails>(
      {url: `/api/dj-rest-auth/user/`, method: 'patch',
      headers: {'Content-Type': 'application/json', },
      data: patchedUserDetails
    },
      options);
    }
  


export const getApiDjRestAuthUserPartialUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>, TError,{data: NonReadonly<PatchedUserDetails>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>, TError,{data: NonReadonly<PatchedUserDetails>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>, {data: NonReadonly<PatchedUserDetails>}> = (props) => {
          const {data} = props ?? {};

          return  apiDjRestAuthUserPartialUpdate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiDjRestAuthUserPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>>
    export type ApiDjRestAuthUserPartialUpdateMutationBody = NonReadonly<PatchedUserDetails>
    export type ApiDjRestAuthUserPartialUpdateMutationError = unknown

    export const useApiDjRestAuthUserPartialUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiDjRestAuthUserPartialUpdate>>, TError,{data: NonReadonly<PatchedUserDetails>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiDjRestAuthUserPartialUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiEnergyLogsList = (
    params?: ApiEnergyLogsListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<PaginatedEnergyPriceLogModelList>(
      {url: `/api/energy-logs/`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getApiEnergyLogsListQueryKey = (params?: ApiEnergyLogsListParams,) => [`/api/energy-logs/`, ...(params ? [params]: [])] as const;
  

    
export const getApiEnergyLogsListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiEnergyLogsList>>, TError = unknown>(params?: ApiEnergyLogsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiEnergyLogsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiEnergyLogsList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEnergyLogsListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEnergyLogsList>>> = ({ signal }) => apiEnergyLogsList(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiEnergyLogsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiEnergyLogsList>>>
export type ApiEnergyLogsListInfiniteQueryError = unknown

export const useApiEnergyLogsListInfinite = <TData = Awaited<ReturnType<typeof apiEnergyLogsList>>, TError = unknown>(
 params?: ApiEnergyLogsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiEnergyLogsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiEnergyLogsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiEnergyLogsListQueryOptions = <TData = Awaited<ReturnType<typeof apiEnergyLogsList>>, TError = unknown>(params?: ApiEnergyLogsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiEnergyLogsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiEnergyLogsList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEnergyLogsListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEnergyLogsList>>> = ({ signal }) => apiEnergyLogsList(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiEnergyLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiEnergyLogsList>>>
export type ApiEnergyLogsListQueryError = unknown

export const useApiEnergyLogsList = <TData = Awaited<ReturnType<typeof apiEnergyLogsList>>, TError = unknown>(
 params?: ApiEnergyLogsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiEnergyLogsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiEnergyLogsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

/**
 * Upload CSV and seed the EnergyPriceLog model.
 */
export const apiEnergyLogsUploadCsvCreate = (
    apiEnergyLogsUploadCsvCreateBody: ApiEnergyLogsUploadCsvCreateBody,
 options?: SecondParameter<typeof axiosInstance>,) => {const formData = new FormData();
formData.append('file', apiEnergyLogsUploadCsvCreateBody.file)

      return axiosInstance<ApiEnergyLogsUploadCsvCreate201>(
      {url: `/api/energy-logs/upload_csv/`, method: 'post',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      options);
    }
  


export const getApiEnergyLogsUploadCsvCreateMutationOptions = <TError = ApiEnergyLogsUploadCsvCreate400,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEnergyLogsUploadCsvCreate>>, TError,{data: ApiEnergyLogsUploadCsvCreateBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiEnergyLogsUploadCsvCreate>>, TError,{data: ApiEnergyLogsUploadCsvCreateBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEnergyLogsUploadCsvCreate>>, {data: ApiEnergyLogsUploadCsvCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  apiEnergyLogsUploadCsvCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiEnergyLogsUploadCsvCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEnergyLogsUploadCsvCreate>>>
    export type ApiEnergyLogsUploadCsvCreateMutationBody = ApiEnergyLogsUploadCsvCreateBody
    export type ApiEnergyLogsUploadCsvCreateMutationError = ApiEnergyLogsUploadCsvCreate400

    export const useApiEnergyLogsUploadCsvCreate = <TError = ApiEnergyLogsUploadCsvCreate400,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiEnergyLogsUploadCsvCreate>>, TError,{data: ApiEnergyLogsUploadCsvCreateBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiEnergyLogsUploadCsvCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * OpenApi3 schema for this API. Format can be selected via content negotiation.

- YAML: application/vnd.oai.openapi
- JSON: application/vnd.oai.openapi+json
 */
export const apiSchemaRetrieve = (
    params?: ApiSchemaRetrieveParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<ApiSchemaRetrieve200One | ApiSchemaRetrieve200Two | ApiSchemaRetrieve200Three | ApiSchemaRetrieve200Four>(
      {url: `/api/schema/`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getApiSchemaRetrieveQueryKey = (params?: ApiSchemaRetrieveParams,) => [`/api/schema/`, ...(params ? [params]: [])] as const;
  

    
export const getApiSchemaRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = unknown>(params?: ApiSchemaRetrieveParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiSchemaRetrieveQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiSchemaRetrieve>>> = ({ signal }) => apiSchemaRetrieve(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiSchemaRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiSchemaRetrieve>>>
export type ApiSchemaRetrieveInfiniteQueryError = unknown

export const useApiSchemaRetrieveInfinite = <TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = unknown>(
 params?: ApiSchemaRetrieveParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiSchemaRetrieveInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiSchemaRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = unknown>(params?: ApiSchemaRetrieveParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiSchemaRetrieveQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiSchemaRetrieve>>> = ({ signal }) => apiSchemaRetrieve(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiSchemaRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiSchemaRetrieve>>>
export type ApiSchemaRetrieveQueryError = unknown

export const useApiSchemaRetrieve = <TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = unknown>(
 params?: ApiSchemaRetrieveParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiSchemaRetrieveQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const apiUserCarChargeLogsList = (
    params?: ApiUserCarChargeLogsListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<PaginatedUserCarChargeLogModelList>(
      {url: `/api/user-car-charge-logs/`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getApiUserCarChargeLogsListQueryKey = (params?: ApiUserCarChargeLogsListParams,) => [`/api/user-car-charge-logs/`, ...(params ? [params]: [])] as const;
  

    
export const getApiUserCarChargeLogsListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError = unknown>(params?: ApiUserCarChargeLogsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUserCarChargeLogsListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>> = ({ signal }) => apiUserCarChargeLogsList(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUserCarChargeLogsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>>
export type ApiUserCarChargeLogsListInfiniteQueryError = unknown

export const useApiUserCarChargeLogsListInfinite = <TData = Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError = unknown>(
 params?: ApiUserCarChargeLogsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUserCarChargeLogsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiUserCarChargeLogsListQueryOptions = <TData = Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError = unknown>(params?: ApiUserCarChargeLogsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUserCarChargeLogsListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>> = ({ signal }) => apiUserCarChargeLogsList(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUserCarChargeLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>>
export type ApiUserCarChargeLogsListQueryError = unknown

export const useApiUserCarChargeLogsList = <TData = Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError = unknown>(
 params?: ApiUserCarChargeLogsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUserCarChargeLogsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUserCarChargeLogsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const apiUserCarsList = (
    params?: ApiUserCarsListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<PaginatedUserCarModelList>(
      {url: `/api/user-cars/`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getApiUserCarsListQueryKey = (params?: ApiUserCarsListParams,) => [`/api/user-cars/`, ...(params ? [params]: [])] as const;
  

    
export const getApiUserCarsListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiUserCarsList>>, TError = unknown>(params?: ApiUserCarsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUserCarsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUserCarsList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUserCarsListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUserCarsList>>> = ({ signal }) => apiUserCarsList(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUserCarsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiUserCarsList>>>
export type ApiUserCarsListInfiniteQueryError = unknown

export const useApiUserCarsListInfinite = <TData = Awaited<ReturnType<typeof apiUserCarsList>>, TError = unknown>(
 params?: ApiUserCarsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUserCarsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUserCarsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiUserCarsListQueryOptions = <TData = Awaited<ReturnType<typeof apiUserCarsList>>, TError = unknown>(params?: ApiUserCarsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUserCarsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiUserCarsList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUserCarsListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUserCarsList>>> = ({ signal }) => apiUserCarsList(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUserCarsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiUserCarsList>>>
export type ApiUserCarsListQueryError = unknown

export const useApiUserCarsList = <TData = Awaited<ReturnType<typeof apiUserCarsList>>, TError = unknown>(
 params?: ApiUserCarsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUserCarsList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUserCarsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const apiUserCarsCreate = (
    userCarModel: NonReadonly<UserCarModel>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<UserCarModel>(
      {url: `/api/user-cars/`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: userCarModel
    },
      options);
    }
  


export const getApiUserCarsCreateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsCreate>>, TError,{data: NonReadonly<UserCarModel>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsCreate>>, TError,{data: NonReadonly<UserCarModel>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUserCarsCreate>>, {data: NonReadonly<UserCarModel>}> = (props) => {
          const {data} = props ?? {};

          return  apiUserCarsCreate(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiUserCarsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiUserCarsCreate>>>
    export type ApiUserCarsCreateMutationBody = NonReadonly<UserCarModel>
    export type ApiUserCarsCreateMutationError = unknown

    export const useApiUserCarsCreate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsCreate>>, TError,{data: NonReadonly<UserCarModel>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiUserCarsCreateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiUserCarsRetrieve = (
    id: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<UserCarDetailModel>(
      {url: `/api/user-cars/${id}/`, method: 'get', signal
    },
      options);
    }
  

export const getApiUserCarsRetrieveQueryKey = (id: number,) => [`/api/user-cars/${id}/`] as const;
  

    
export const getApiUserCarsRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUserCarsRetrieveQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUserCarsRetrieve>>> = ({ signal }) => apiUserCarsRetrieve(id, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(id),  staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUserCarsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiUserCarsRetrieve>>>
export type ApiUserCarsRetrieveInfiniteQueryError = unknown

export const useApiUserCarsRetrieveInfinite = <TData = Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUserCarsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiUserCarsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUserCarsRetrieveQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUserCarsRetrieve>>> = ({ signal }) => apiUserCarsRetrieve(id, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(id),  staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUserCarsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiUserCarsRetrieve>>>
export type ApiUserCarsRetrieveQueryError = unknown

export const useApiUserCarsRetrieve = <TData = Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUserCarsRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUserCarsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const apiUserCarsUpdate = (
    id: number,
    userCarModel: NonReadonly<UserCarModel>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<UserCarModel>(
      {url: `/api/user-cars/${id}/`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: userCarModel
    },
      options);
    }
  


export const getApiUserCarsUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsUpdate>>, TError,{id: number;data: NonReadonly<UserCarModel>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsUpdate>>, TError,{id: number;data: NonReadonly<UserCarModel>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUserCarsUpdate>>, {id: number;data: NonReadonly<UserCarModel>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiUserCarsUpdate(id,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiUserCarsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiUserCarsUpdate>>>
    export type ApiUserCarsUpdateMutationBody = NonReadonly<UserCarModel>
    export type ApiUserCarsUpdateMutationError = unknown

    export const useApiUserCarsUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsUpdate>>, TError,{id: number;data: NonReadonly<UserCarModel>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiUserCarsUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiUserCarsPartialUpdate = (
    id: number,
    patchedUserCarModel: NonReadonly<PatchedUserCarModel>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<UserCarModel>(
      {url: `/api/user-cars/${id}/`, method: 'patch',
      headers: {'Content-Type': 'application/json', },
      data: patchedUserCarModel
    },
      options);
    }
  


export const getApiUserCarsPartialUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedUserCarModel>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedUserCarModel>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUserCarsPartialUpdate>>, {id: number;data: NonReadonly<PatchedUserCarModel>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiUserCarsPartialUpdate(id,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiUserCarsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiUserCarsPartialUpdate>>>
    export type ApiUserCarsPartialUpdateMutationBody = NonReadonly<PatchedUserCarModel>
    export type ApiUserCarsPartialUpdateMutationError = unknown

    export const useApiUserCarsPartialUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedUserCarModel>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiUserCarsPartialUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiUserCarsDestroy = (
    id: number,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/user-cars/${id}/`, method: 'delete'
    },
      options);
    }
  


export const getApiUserCarsDestroyMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsDestroy>>, TError,{id: number}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUserCarsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiUserCarsDestroy(id,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiUserCarsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiUserCarsDestroy>>>
    
    export type ApiUserCarsDestroyMutationError = unknown

    export const useApiUserCarsDestroy = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUserCarsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiUserCarsDestroyMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiUsersList = (
    params?: ApiUsersListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<PaginatedUserList>(
      {url: `/api/users/`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getApiUsersListQueryKey = (params?: ApiUsersListParams,) => [`/api/users/`, ...(params ? [params]: [])] as const;
  

    
export const getApiUsersListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersList>>, TError = unknown>(params?: ApiUsersListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersList>>> = ({ signal }) => apiUsersList(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersList>>>
export type ApiUsersListInfiniteQueryError = unknown

export const useApiUsersListInfinite = <TData = Awaited<ReturnType<typeof apiUsersList>>, TError = unknown>(
 params?: ApiUsersListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiUsersListQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersList>>, TError = unknown>(params?: ApiUsersListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersList>>> = ({ signal }) => apiUsersList(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersListQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersList>>>
export type ApiUsersListQueryError = unknown

export const useApiUsersList = <TData = Awaited<ReturnType<typeof apiUsersList>>, TError = unknown>(
 params?: ApiUsersListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersList>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const apiUsersRetrieve = (
    username: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<User>(
      {url: `/api/users/${username}/`, method: 'get', signal
    },
      options);
    }
  

export const getApiUsersRetrieveQueryKey = (username: string,) => [`/api/users/${username}/`] as const;
  

    
export const getApiUsersRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersRetrieve>>, TError = unknown>(username: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersRetrieveQueryKey(username);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersRetrieve>>> = ({ signal }) => apiUsersRetrieve(username, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(username),  staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersRetrieve>>>
export type ApiUsersRetrieveInfiniteQueryError = unknown

export const useApiUsersRetrieveInfinite = <TData = Awaited<ReturnType<typeof apiUsersRetrieve>>, TError = unknown>(
 username: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersRetrieveInfiniteQueryOptions(username,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiUsersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersRetrieve>>, TError = unknown>(username: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersRetrieveQueryKey(username);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersRetrieve>>> = ({ signal }) => apiUsersRetrieve(username, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(username),  staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersRetrieve>>>
export type ApiUsersRetrieveQueryError = unknown

export const useApiUsersRetrieve = <TData = Awaited<ReturnType<typeof apiUsersRetrieve>>, TError = unknown>(
 username: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersRetrieveQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const apiUsersUpdate = (
    username: string,
    user: NonReadonly<User>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<User>(
      {url: `/api/users/${username}/`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: user
    },
      options);
    }
  


export const getApiUsersUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersUpdate>>, TError,{username: string;data: NonReadonly<User>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersUpdate>>, TError,{username: string;data: NonReadonly<User>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersUpdate>>, {username: string;data: NonReadonly<User>}> = (props) => {
          const {username,data} = props ?? {};

          return  apiUsersUpdate(username,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiUsersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersUpdate>>>
    export type ApiUsersUpdateMutationBody = NonReadonly<User>
    export type ApiUsersUpdateMutationError = unknown

    export const useApiUsersUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersUpdate>>, TError,{username: string;data: NonReadonly<User>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiUsersUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiUsersPartialUpdate = (
    username: string,
    patchedUser: NonReadonly<PatchedUser>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<User>(
      {url: `/api/users/${username}/`, method: 'patch',
      headers: {'Content-Type': 'application/json', },
      data: patchedUser
    },
      options);
    }
  


export const getApiUsersPartialUpdateMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersPartialUpdate>>, TError,{username: string;data: NonReadonly<PatchedUser>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersPartialUpdate>>, TError,{username: string;data: NonReadonly<PatchedUser>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersPartialUpdate>>, {username: string;data: NonReadonly<PatchedUser>}> = (props) => {
          const {username,data} = props ?? {};

          return  apiUsersPartialUpdate(username,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ApiUsersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersPartialUpdate>>>
    export type ApiUsersPartialUpdateMutationBody = NonReadonly<PatchedUser>
    export type ApiUsersPartialUpdateMutationError = unknown

    export const useApiUsersPartialUpdate = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersPartialUpdate>>, TError,{username: string;data: NonReadonly<PatchedUser>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getApiUsersPartialUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    export const apiUsersMeRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<User>(
      {url: `/api/users/me/`, method: 'get', signal
    },
      options);
    }
  

export const getApiUsersMeRetrieveQueryKey = () => [`/api/users/me/`] as const;
  

    
export const getApiUsersMeRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError = unknown>( options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersMeRetrieveQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersMeRetrieve>>> = ({ signal }) => apiUsersMeRetrieve(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersMeRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersMeRetrieve>>>
export type ApiUsersMeRetrieveInfiniteQueryError = unknown

export const useApiUsersMeRetrieveInfinite = <TData = Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError = unknown>(
  options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersMeRetrieveInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

export const getApiUsersMeRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersMeRetrieveQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersMeRetrieve>>> = ({ signal }) => apiUsersMeRetrieve(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn,   staleTime: Infinity, refetchOnWindowFocus: false, retry: 1,  ...queryOptions}}

export type ApiUsersMeRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersMeRetrieve>>>
export type ApiUsersMeRetrieveQueryError = unknown

export const useApiUsersMeRetrieve = <TData = Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof apiUsersMeRetrieve>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getApiUsersMeRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

